[{"type":"tab","id":"2153ec83.169f54","label":"Email Tachos"},{"id":"b21e0c9e.b81ff","type":"scheduler","z":"2153ec83.169f54","outtopic":"","outpayload1":"","outpayload2":"","name":"Scheduler","lat":"43.52249","lon":"-5.61155","start":"sunrise","end":"sunset","starttime":"1380","endtime":"1395","duskoff":"0","dawnoff":"0","outtext1":"ON","outtext2":"OFF","sun":true,"mon":true,"tue":true,"wed":true,"thu":true,"fri":true,"sat":true,"jan":true,"feb":true,"mar":true,"apr":true,"may":true,"jun":true,"jul":true,"aug":true,"sep":true,"oct":true,"nov":true,"dec":true,"repeat":false,"atstart":true,"x":121,"y":131,"wires":[[],[],["b8fec780.8dea68"]]},{"id":"723995d8.9df14c","type":"function","z":"2153ec83.169f54","name":"Email Tachos","func":"console.log('Start Email Tachos node');\n\n//var fs = context.global.fs;\nvar Imap = context.global.imap;\nvar base64 = context.global.base64Stream;\nvar streamm = context.global.stream;\nvar request = context.global.request;\n\n// get organization active\nvar organization = msg.payload;\n\nif (organization.mailboxEmail === undefined)\n    return;\n\nconsole.log('Download email tachos for Organization Id: ' + organization.id + ' with name ' + organization.name);\n\nvar imap = new Imap({\n    user: organization.mailboxEmail,\n    password: organization.mailboxPassword,\n    host: 'imap.gmail.com',\n    port: 993,\n    tls: true\n});\n\nfunction findAttachmentParts(struct, attachments) {\n    attachments = attachments ||  [];\n\n    for (var i = 0, len = struct.length, r; i < len; ++i) {\n        if (Array.isArray(struct[i])) {\n            findAttachmentParts(struct[i], attachments);\n        } else {\n            if (struct[i].disposition && ['INLINE', 'ATTACHMENT'].indexOf(struct[i].disposition.type) > -1) {\n                attachments.push(struct[i]);\n            }\n        }\n    }\n\n    return attachments;\n}\n\nfunction buildAttMessageFunction(attachment) {\n    var filename = attachment.params.name;\n    var encoding = attachment.encoding;\n    \n    return function (message, seqno) {\n        var prefix = '(#' + seqno + ') ';\n\n        message.on('body', function(stream, info) {\n            //Create a write stream so that we can stream the attachment to file;\n            console.log(prefix + 'Streaming this attachment to file', filename, info);\n            \n            // create final stream\n            var bufferStream = new streamm.PassThrough();\n            if (encoding === 'BASE64') {\n                //the stream is base64 encoded, so here the stream is decode on the fly and piped to the write stream (file)\n                stream.pipe(base64.decode()).pipe(bufferStream);\n            } else  {\n                //here we have none or some other decoding streamed directly to the file which renders it useless probably\n                stream.pipe(bufferStream);\n            }\n\n            // recover the new stream and pass to the next node\n            var chunks = [];\n            bufferStream.on('data', function(data) {\n                chunks.push(data);\n            });\n\n            bufferStream.on('end', function() {\n                var body = Buffer.concat(chunks);\n                console.log('File size: ' + body.length);\n                \n                // pass to the next node\n                var formData = {\"organization\": JSON.stringify(organization), \n                                \"file\": {\"value\": body, \"options\": {\"filename\": filename}}};\n                            \n                console.log(\"Organization: \" + formData);\n                \n                request.post({url:'http://192.168.1.100:3000/services/rest/files/uploader', formData: formData}, function(err, httpResponse, body) {\n                    if (err)\n                        node.send(err);\n        \n                    console.log('Upload successful!  Server responded with:', body);\n    \n                    msg.payload = body;\n                    node.send(msg);\n                });                            \n            });\n            \n            /*var writeStream = fs.createWriteStream(filename);\n\n            writeStream.on('finish', function() {\n                console.log(prefix + 'Done writing to file %s', filename);\n                \n                msg.payload = {\"organization\": organization, \"file\": writeStream};\n                node.send(msg);\n            });\n\n            //stream.pipe(writeStream); this would write base64 data to the file. So we decode during streaming using\n            if (encoding === 'BASE64') {\n                //the stream is base64 encoded, so here the stream is decode on the fly and piped to the write stream (file)\n                stream.pipe(base64.decode()).pipe(writeStream);\n            } else  {\n                //here we have none or some other decoding streamed directly to the file which renders it useless probably\n                stream.pipe(writeStream);\n            }*/\n        });\n\n        message.once('end', function() {\n            console.log(prefix + 'Finished attachment %s', filename);\n        });\n    };\n}\n\nimap.once('ready', function() {\n    imap.openBox('INBOX', false, function(err, box) {\n        if (err) throw err;\n\n        console.log('Searching emails from: ', organization.name);\n        imap.search([ 'UNSEEN', ['SINCE', 'May 24, 2016'] ], function(err, results) {\n            if (err) throw err;\n\n            if (results.length === 0)\n                return;\n\n            //var f = imap.seq.fetch('1:3', {struct: true, markSeen:true, bodies: ['HEADER.FIELDS (FROM TO SUBJECT DATE)']});\n            var f = imap.fetch(results, { struct: true, markSeen:true, bodies: '' });\n\n            f.on('message', function (msg, seqno) {\n                console.log('Message #%d', seqno);\n                var prefix = '(#' + seqno + ') ';\n\n                msg.on('body', function(stream, info) {\n                    var buffer = '';\n                    stream.on('data', function(chunk) {\n                        buffer += chunk.toString('utf8');\n                    });\n                    stream.once('end', function() {\n                        console.log(prefix + 'Parsed header: %s', Imap.parseHeader(buffer));\n                    });\n                });\n\n                msg.once('attributes', function(attrs) {\n                    var attachments = findAttachmentParts(attrs.struct);\n\n                    if (attachments === undefined)\n                        return;\n\n                    console.log(prefix + 'Has attachments: %d', attachments.length);\n                    for (var i = 0, len=attachments.length ; i < len; ++i) {\n                        var attachment = attachments[i];\n                        /*This is how each attachment looks like {\n                             partID: '2',\n                             type: 'application',\n                             subtype: 'octet-stream',\n                             params: { name: 'file-name.ext' },\n                             id: null,\n                             description: null,\n                             encoding: 'BASE64',\n                             size: 44952,\n                             md5: null,\n                             disposition: { type: 'ATTACHMENT', params: { filename: 'file-name.ext' } },\n                             language: null\n                             }\n                         */\n                        console.log(prefix + 'Fetching attachment %s', attachment.params.name);\n                        \n                        if (attachment.params.name === undefined)\n                            return;\n                            \n                        if (attachment.params.name.toUpperCase().indexOf(\".TGD\") < 0 &&\n                            attachment.params.name.toUpperCase().indexOf(\".DDD\") < 0 &&\n                            attachment.params.name.toUpperCase().indexOf(\".C1V\") < 0)\n                                return;\n                            \n                        var f = imap.fetch(attrs.uid , {bodies: [attachment.partID], struct: true });\n\n                        //build function to process attachment message\n                        f.on('message', buildAttMessageFunction(attachment));\n                    }\n                });\n                msg.once('end', function() {\n                    console.log(prefix + 'Finished email');\n                });\n            });\n\n            f.once('error', function(err) {\n                console.log('Fetch error: ' + err);\n            });\n\n            f.once('end', function() {\n                console.log('Done fetching all messages!');\n                imap.end();\n            });\n        });\n    });\n});\n\nimap.once('error', function(err) {\n    console.log(err);\n});\n\nimap.once('end', function() {\n    console.log('Connection ended');\n});\n\nimap.connect();\n\nreturn;","outputs":1,"noerr":0,"x":619,"y":289,"wires":[["67dfeb62.495974"]]},{"id":"b8fec780.8dea68","type":"http request","z":"2153ec83.169f54","name":"Get Organizations","method":"GET","ret":"obj","url":"http://localhost:3000/services/rest/Organizations?filter={\"where\": {\"mailboxEmail\": {\"neq\":  null }}}","x":210,"y":289,"wires":[["430093b1.e6494c"]]},{"id":"430093b1.e6494c","type":"splitter","z":"2153ec83.169f54","name":"Organizations Loop","property":"payload","x":420,"y":289,"wires":[["723995d8.9df14c"]]},{"id":"67dfeb62.495974","type":"debug","z":"2153ec83.169f54","name":"","active":true,"console":"false","complete":"false","x":738,"y":131,"wires":[]}]