[{"type":"tab","id":"39d45587.c62baa","label":"Microcom"},{"type":"tab","id":"f298e8d.f0d6718","label":"Syscom"},{"type":"tab","id":"39846ab7.c67b96","label":"Digi"},{"type":"tab","id":"63e2f707.9c1d08","label":"Loopback"},{"type":"tab","id":"a95e591a.56a1a8","label":"File test"},{"type":"tab","id":"2153ec83.169f54","label":"Email Tachos"},{"id":"2062f52f.df9d0a","type":"mongodb2","z":"f298e8d.f0d6718","hostname":"127.0.0.1","port":"27017","db":"nodesensor","name":"","options":"","parallelism":"-1"},{"id":"8035c134.7fca4","type":"mongodb2","z":"39846ab7.c67b96","hostname":"127.0.0.1","port":"27017","db":"nodesensor","name":"","options":"","parallelism":"-1"},{"id":"7349c91a.8cb638","type":"watch","z":"39d45587.c62baa","name":"in-box","files":"/home/miguel/nodesensor/datalogger/","x":79,"y":67,"wires":[["f4f6a4f2.0b0958"]]},{"id":"33712759.cc8ed8","type":"function","z":"39d45587.c62baa","name":"historic 01","func":"console.log('Start historic 01 node');\n\nvar fs = context.global.fs;\n\nif (fs === undefined)\n    node.error(\"fs module is not accessible\", msg);\n\n// move sensor file to historic folder\nfs.rename('/home/miguel/nodesensor/datalogger/' + msg.file, '/home/miguel/nodesensor/datalogger/.historic/' + msg.file, function (err) {\n    if (err) node.error(\"Historic error\", msg);\n    \n    node.log('Historic complete');\n    \n    node.send(msg);\n});\n\nreturn;","outputs":1,"noerr":0,"x":642,"y":67,"wires":[["198ddd74.e67223"]]},{"id":"f4f6a4f2.0b0958","type":"function","z":"39d45587.c62baa","name":"parse","func":"console.log('Start parse node');\n\nvar fs = context.global.fs;\nvar moment = context.global.moment;\n\nif (fs === undefined)\n    node.error(\"fs module is not accessible\", msg);\n\n// preveent when remove files. The watch fire with a none file\nif (msg.type == 'none')   \n    return;\n\n// recover gateway from file name\nvar tokens = msg.file.split(\"_\");\nvar gateway = tokens[0];\nconsole.log('Gateway name: ' + gateway);   \n\n// recover sensor file from folder\nfs.readFile('/home/miguel/nodesensor/datalogger/' + msg.file, function(err, data) {\n    if (err) node.error(\"Reading file error\", msg);\n\n    if (data === undefined) {\n        console.log('data is undefined');   \n        node.error(\"file undefined\", msg);\n    }\n    \n    var array = data.toString().split(\"\\n\");\n    \n    var measurement = [];\n    for(var line in array) {\n        var register = array[line];\n        \n        var sensor = {};\n        sensor.date = moment(register.substring(2, 12), \"YYMMDDHHmm\").toDate();\n        sensor.channel = register.substring(12, 14);\n        sensor.reason = register.substring(14, 16);\n        sensor.value = parseFloat(register.substring(16));\n        \n        // add sensor measure to the collection\n        measurement.push(sensor);\n    }\n    \n    // initialize context measurement\n    msg.collection = 'Track';\n    msg.operation  = 'insertMany';\n    msg.payload = measurement;\n    msg.gateway = gateway;\n    \n    console.log('Persist ' + msg.payload.length + ' measures');\n\n    node.send(msg);\n});\n\nreturn;","outputs":"1","noerr":0,"x":249,"y":67,"wires":[["a365066.f5c9af8"]]},{"id":"198ddd74.e67223","type":"debug","z":"39d45587.c62baa","name":"out debug","active":true,"console":"false","complete":"file","x":820,"y":67,"wires":[]},{"id":"dba719f.f2458e8","type":"catch","z":"39d45587.c62baa","name":"catch all","scope":["b1d62e3.f4e29d","af35da82.50ca28"],"x":181,"y":256,"wires":[["c42d5d73.3bd2a"]]},{"id":"d09a8723.2f6578","type":"debug","z":"39d45587.c62baa","name":"error","active":true,"console":"false","complete":"error.message","x":538,"y":256,"wires":[]},{"id":"c42d5d73.3bd2a","type":"function","z":"39d45587.c62baa","name":"historic 02","func":"console.log('Start historic 02 node');\n\nvar fs = context.global.fs;\n\nif (fs === undefined)\n    node.error(\"fs module is not accessible\", msg);\n\nif (msg.file === undefined)\n    return msg;\n    \n// move sensor file to historic folder\nfs.rename('/home/miguel/nodesensor/datalogger/' + msg.file, '/home/miguel/nodesensor/datalogger/.historic/' + msg.file, function (err) {\n    if (err) node.error(\"Historic error\", msg);\n\n    node.log('Historic complete');\n    \n    node.send(msg);\n});\n\nreturn;","outputs":1,"noerr":0,"x":362,"y":256,"wires":[["d09a8723.2f6578"]]},{"id":"a365066.f5c9af8","type":"function","z":"39d45587.c62baa","name":"loopback persist","func":"var loopback = context.global.loopback;\nvar DeviceHub = loopback.models.DeviceHub;\nvar Device = loopback.models.Device;\nvar Track = loopback.models.Track;\n\nDeviceHub.findOne({ where: {code: msg.gateway}}, function (err, deviceHub) {\n    if (err) node.error(\"DeviceHub findOne error\", msg);\n\n    // generate track collection \n    msg.payload.forEach(function(measurement) {\n        Device.findOne({ where: {deviceHubId: deviceHub.id, code: measurement.channel}}, function (err, device) {\n            if (err) node.error(\"Device findOne error\", msg);\n            \n            if(device !== null) {\n                console.log('Channel: ' + measurement.channel + ' is Device id: ' + device.id + ' value:' + measurement.value + ' date: ' + measurement.date); \n                \n                // persist track collection\n                Track.create({'deviceId': device.id, 'value': measurement.value, 'date': measurement.date}, function (err, track) {\n                    if (err) node.error(\"Track create error\", msg);\n                });\n            }\n        });\n    });\n\n    node.send(msg);\n});\n\nreturn;","outputs":1,"noerr":0,"x":439,"y":67,"wires":[["33712759.cc8ed8"]]},{"id":"775c50b0.88a3b","type":"watch","z":"f298e8d.f0d6718","name":"in-box","files":"/home/miguel/nodesensor/accelerometer/","x":85,"y":61,"wires":[["c6e3a27f.391c6"]]},{"id":"c6e3a27f.391c6","type":"function","z":"f298e8d.f0d6718","name":"parser","func":"console.log('Start parse node');\n\nvar fs = context.global.fs;\nvar moment = context.global.moment;\n\nif (fs === undefined)\n    node.error(\"fs module is not accessible\", msg);\n\n// preveent when remove files. The watch fire with a none file\nif (msg.type == 'none')   \n    return;\n        \n// recover sensor file from folder\nfs.readFile('/home/miguel/nodesensor/accelerometer/' + msg.file, function(err, data) {\n    if (err) \n        node.error(\"Reading file error\", msg);\n\n    var array = data.toString().split(\"\\n\");\n\n    // define channels position and name\n    var Time=0\n    var X=1, CHANNEL_X=\"CHANNEL_X\";\n    var Y=2, CHANNEL_Y=\"CHANNEL_Y\";\n    var Z=3, CHANNEL_Z=\"CHANNEL_Z\";\n    \n    // measurement collection\n    var measurement = [];\n    \n    // hub name and measurement moment\n    var hub;\n    var startDate;\n    for(var line in array) {\n        var register = array[line];\n        \n        // get hub name\n        if (register == '# [Recorder]') {\n            hub = array[Number(line)+2].substring(7, array[Number(line)+2].length);\n            console.log('Hub name: ' + hub);\n        }\n        \n        // get start date/time\n        if (register == '# [File]') {\n            startDate = moment(array[Number(line)+3].substring(12, array[Number(line)+3].length) +\n                               \" \" +\n                               array[Number(line)+4].substring(12, array[Number(line)+4].length),\n                              \"YYYY-MM-DD HH:mm:ss.sss\").toDate();\n            console.log('Start date: ' + startDate);\n        }\n            \n        // get measurements\n        if (register.substring(0, 1) != '#') {\n            var token = register.toString().split(\" \");\n            \n            // get X channel sata\n            var sensor_X = {};\n            sensor_X.date = moment(startDate).add(token[Time], 'seconds').toDate();\n            sensor_X.channel = CHANNEL_X;\n            sensor_X.reason = null;\n            sensor_X.value = parseFloat(token[X]);\n\n            measurement.push(sensor_X);\n            \n            // get Y channel sata\n            var sensor_Y = {};\n            sensor_Y.date = moment(startDate).add(token[Time], 'seconds').toDate();\n            sensor_Y.channel = CHANNEL_Y;\n            sensor_Y.reason = null;\n            sensor_Y.value = parseFloat(token[Y]);\n\n            measurement.push(sensor_Y);\n            \n            // get Z channel sata\n            var sensor_Z = {};\n            sensor_Z.date = moment(startDate).add(token[Time], 'seconds').toDate();\n            sensor_Z.channel = CHANNEL_Z;\n            sensor_Z.reason = null;\n            sensor_Z.value = parseFloat(token[Z]);\n\n            measurement.push(sensor_Z);           \n        }\n    }\n    \n    // initialize context measurement\n    msg.collection = 'Track';\n    msg.operation  = 'insertMany';\n    msg.payload    = [];\n    msg.payload.push(measurement);    \n    \n    console.log('Persist ' + msg.payload[0].length + ' measures');\n\n    node.send(msg);\n});\n\nreturn;","outputs":1,"noerr":0,"x":270,"y":61,"wires":[["724a439b.8db5bc"]]},{"id":"724a439b.8db5bc","type":"mongodb2 in","z":"f298e8d.f0d6718","service":"_ext_","configNode":"2062f52f.df9d0a","name":"persist","collection":"","operation":"","x":459,"y":61,"wires":[["b7e463d.f481ba"]]},{"id":"b7e463d.f481ba","type":"function","z":"f298e8d.f0d6718","name":"historic 01","func":"console.log('Start historic 01 node');\n\nvar fs = context.global.fs;\n\nif (fs === undefined)\n    node.error(\"fs module is not accessible\", msg);\n\n// move sensor file to historic folder\nfs.rename('/home/miguel/nodesensor/accelerometer/' + msg.file, '/home/miguel/nodesensor/accelerometer/.historic/' + msg.file, function (err) {\n    if (err) node.error(\"Historic error\", msg);\n    \n    node.log('Historic complete');\n    \n    node.send(msg);\n});\n\nreturn;","outputs":1,"noerr":0,"x":652,"y":61,"wires":[["6c9c4528.9363bc"]]},{"id":"6c9c4528.9363bc","type":"debug","z":"f298e8d.f0d6718","name":"out debug","active":true,"console":"false","complete":"payload","x":868,"y":61,"wires":[]},{"id":"6e500507.91affc","type":"catch","z":"f298e8d.f0d6718","name":"","scope":null,"x":204,"y":223,"wires":[["1a9826e2.e567d9"]]},{"id":"1a9826e2.e567d9","type":"function","z":"f298e8d.f0d6718","name":"historic 02","func":"console.log('Start historic 02 node');\n\nvar fs = context.global.fs;\n\nif (fs === undefined)\n    node.error(\"fs module is not accessible\", msg);\n\nif (msg.file === undefined)\n    return msg;\n    \n// move sensor file to historic folder\nfs.rename('/home/miguel/nodesensor/accelerometer/' + msg.file, '/home/miguel/nodesensor/accelerometer/.historic/' + msg.file, function (err) {\n    if (err) node.error(\"Historic error\", msg);\n\n    node.log('Historic complete');\n    \n    node.send(msg);\n});\n\nreturn;","outputs":1,"noerr":0,"x":405,"y":223,"wires":[["5a5a1588.a5a5ec"]]},{"id":"5a5a1588.a5a5ec","type":"debug","z":"f298e8d.f0d6718","name":"error","active":true,"console":"false","complete":"payload","x":624,"y":223,"wires":[]},{"id":"571eba86.a8e144","type":"inject","z":"39846ab7.c67b96","name":"","topic":"","payload":"","payloadType":"none","repeat":"","crontab":"","once":false,"x":97,"y":79,"wires":[["781d4df2.87e2b4"]]},{"id":"781d4df2.87e2b4","type":"http request","z":"39846ab7.c67b96","name":"http digi cloud service","method":"GET","ret":"txt","url":"http://login.etherios.co.uk/ws/DataStream/dia/channel/00000000-00000000-00409DFF-FF7C5D82","x":284,"y":79,"wires":[["d364e702.2c9b18"]]},{"id":"a647817a.59b88","type":"debug","z":"39846ab7.c67b96","name":"out debug","active":true,"console":"false","complete":"payload","x":985,"y":79,"wires":[]},{"id":"d364e702.2c9b18","type":"xml","z":"39846ab7.c67b96","name":"xml parser","attr":"","chr":"","x":489,"y":79,"wires":[["34028db.fcbfd72"]]},{"id":"34028db.fcbfd72","type":"function","z":"39846ab7.c67b96","name":"log","func":"var moment = context.global.moment;\nvar result = msg.payload.result;\nvar measurement = [];\n\nfor (i=0; i<result.DataStream.length; i++) {\n    var sensor = {};\n    \n    sensor.channel = result.DataStream[i].streamId[0];\n    sensor.value = parseFloat(result.DataStream[i].currentValue[0].data);\n    //sensor.date = moment(result.DataStream[i].currentValue[0].serverTimestampISO, moment.ISO_8601).toDate();\n    sensor.date = moment(result.DataStream[i].currentValue[0].serverTimestampISO, \"YYYY-MM-DDTHH:mm:ss Z\").toDate();\n    \n    // add sensor measure to the collection\n    measurement.push(sensor);\n        \n    console.log(\"Channel: \" + sensor.channel);\n    console.log(\"Value: \" + sensor.value);\n    console.log(\"Date: \" + sensor.date);    \n    \n    // initialize context measurement\n    msg.collection = 'Track';\n    msg.operation  = 'insertMany';\n    msg.payload    = [];\n    msg.payload.push(measurement);     \n    \n    console.log('Persist ' + msg.payload.length[0] + ' measures');\n\n}\n\nreturn msg;","outputs":1,"noerr":0,"x":651,"y":79,"wires":[["36317423.c9ce8c"]]},{"id":"36317423.c9ce8c","type":"mongodb2 in","z":"39846ab7.c67b96","service":"_ext_","configNode":"8035c134.7fca4","name":"persist","collection":"","operation":"","x":809,"y":79,"wires":[["a647817a.59b88"]]},{"id":"20796967.df8696","type":"catch","z":"39846ab7.c67b96","name":"","scope":null,"x":330,"y":222,"wires":[["ebf56cc2.140a9"]]},{"id":"ebf56cc2.140a9","type":"debug","z":"39846ab7.c67b96","name":"error","active":true,"console":"false","complete":"payload","x":571,"y":222,"wires":[]},{"id":"c86c7f38.37938","type":"inject","z":"63e2f707.9c1d08","name":"inject","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"x":209,"y":88,"wires":[["c53951.ff3ac6b"]]},{"id":"c53951.ff3ac6b","type":"function","z":"63e2f707.9c1d08","name":"loopback test","func":"var loopback = context.global.loopback;\nvar Device = loopback.models.Device;\n\nDevice.find( { where: { deviceHubId: '566d85a22b937b4350d88d19' }, include: 'deviceType' }, function(err, devices) {\n    if (err) return err;\n\n    for(var i in devices) {\n        console.log('Device: ' + devices[i].code + \" - \" + devices[i].description);\n        console.log('Device Type: ' + devices[i].deviceType().code);\n    }\n\n    msg.payload = devices;\n    node.send(msg);\n});\n\nreturn;","outputs":1,"noerr":0,"x":438,"y":87,"wires":[["258759fd.da78a6"]]},{"id":"258759fd.da78a6","type":"debug","z":"63e2f707.9c1d08","name":"","active":true,"console":"false","complete":"false","x":676,"y":87,"wires":[]},{"id":"49145e6d.b6eba","type":"inject","z":"a95e591a.56a1a8","name":"Inject","topic":"this is topic from the function","payload":"this data is feeded to the function","payloadType":"string","repeat":"","crontab":"","once":false,"x":247,"y":89,"wires":[["6bcd3cf8.9432c4"]]},{"id":"6bcd3cf8.9432c4","type":"file function","z":"a95e591a.56a1a8","name":"loopback test file","filename":".nodered/nodes/sample-file-function.red","reloadfile":false,"outputs":"1","x":488,"y":89,"wires":[["c80db6fc.37f248"]]},{"id":"c80db6fc.37f248","type":"debug","z":"a95e591a.56a1a8","name":"","active":true,"console":"false","complete":"payload","x":715,"y":89,"wires":[]},{"id":"b21e0c9e.b81ff","type":"scheduler","z":"2153ec83.169f54","outtopic":"","outpayload1":"","outpayload2":"","name":"Scheduler","lat":"43.52249","lon":"-5.61155","start":"sunrise","end":"sunset","starttime":"1380","endtime":"1395","duskoff":"0","dawnoff":"0","outtext1":"ON","outtext2":"OFF","sun":true,"mon":true,"tue":true,"wed":true,"thu":true,"fri":true,"sat":true,"jan":true,"feb":true,"mar":true,"apr":true,"may":true,"jun":true,"jul":true,"aug":true,"sep":true,"oct":true,"nov":true,"dec":true,"repeat":false,"atstart":true,"x":121,"y":131,"wires":[[],[],["b8fec780.8dea68"]]},{"id":"723995d8.9df14c","type":"function","z":"2153ec83.169f54","name":"Email Tachos","func":"console.log('Start Email Tachos node');\n\n//var fs = context.global.fs;\nvar Imap = context.global.imap;\nvar base64 = context.global.base64Stream;\nvar streamm = context.global.stream;\nvar request = context.global.request;\n\n// get organization active\nvar organization = msg.payload;\n\nif (organization.mailboxEmail === undefined)\n    return;\n\nconsole.log('Download email tachos for Organization Id: ' + organization.id + ' with name ' + organization.name);\n\nvar imap = new Imap({\n    user: organization.mailboxEmail,\n    password: organization.mailboxPassword,\n    host: 'imap.gmail.com',\n    port: 993,\n    tls: true\n});\n\nfunction findAttachmentParts(struct, attachments) {\n    attachments = attachments ||  [];\n\n    for (var i = 0, len = struct.length, r; i < len; ++i) {\n        if (Array.isArray(struct[i])) {\n            findAttachmentParts(struct[i], attachments);\n        } else {\n            if (struct[i].disposition && ['INLINE', 'ATTACHMENT'].indexOf(struct[i].disposition.type) > -1) {\n                attachments.push(struct[i]);\n            }\n        }\n    }\n\n    return attachments;\n}\n\nfunction buildAttMessageFunction(attachment) {\n    var filename = attachment.params.name;\n    var encoding = attachment.encoding;\n    \n    return function (message, seqno) {\n        var prefix = '(#' + seqno + ') ';\n\n        message.on('body', function(stream, info) {\n            //Create a write stream so that we can stream the attachment to file;\n            console.log(prefix + 'Streaming this attachment to file', filename, info);\n            \n            // create final stream\n            var bufferStream = new streamm.PassThrough();\n            if (encoding === 'BASE64') {\n                //the stream is base64 encoded, so here the stream is decode on the fly and piped to the write stream (file)\n                stream.pipe(base64.decode()).pipe(bufferStream);\n            } else  {\n                //here we have none or some other decoding streamed directly to the file which renders it useless probably\n                stream.pipe(bufferStream);\n            }\n\n            // recover the new stream and pass to the next node\n            var chunks = [];\n            bufferStream.on('data', function(data) {\n                chunks.push(data);\n            });\n\n            bufferStream.on('end', function() {\n                var body = Buffer.concat(chunks);\n                console.log('File size: ' + body.length);\n                \n                // pass to the next node\n                var formData = {\"organization\": JSON.stringify(organization), \n                                \"file\": {\"value\": body, \"options\": {\"filename\": filename}}};\n                            \n                console.log(\"Organization: \" + formData);\n                \n                request.post({url:'http://192.168.1.100:3000/services/rest/files/uploader', formData: formData}, function(err, httpResponse, body) {\n                    if (err)\n                        node.send(err);\n        \n                    console.log('Upload successful!  Server responded with:', body);\n    \n                    msg.payload = body;\n                    node.send(msg);\n                });                            \n            });\n            \n            /*var writeStream = fs.createWriteStream(filename);\n\n            writeStream.on('finish', function() {\n                console.log(prefix + 'Done writing to file %s', filename);\n                \n                msg.payload = {\"organization\": organization, \"file\": writeStream};\n                node.send(msg);\n            });\n\n            //stream.pipe(writeStream); this would write base64 data to the file. So we decode during streaming using\n            if (encoding === 'BASE64') {\n                //the stream is base64 encoded, so here the stream is decode on the fly and piped to the write stream (file)\n                stream.pipe(base64.decode()).pipe(writeStream);\n            } else  {\n                //here we have none or some other decoding streamed directly to the file which renders it useless probably\n                stream.pipe(writeStream);\n            }*/\n        });\n\n        message.once('end', function() {\n            console.log(prefix + 'Finished attachment %s', filename);\n        });\n    };\n}\n\nimap.once('ready', function() {\n    imap.openBox('INBOX', false, function(err, box) {\n        if (err) throw err;\n\n        console.log('Searching emails from: ', organization.name);\n        imap.search([ 'UNSEEN', ['SINCE', 'May 24, 2016'] ], function(err, results) {\n            if (err) throw err;\n\n            if (results.length === 0)\n                return;\n\n            //var f = imap.seq.fetch('1:3', {struct: true, markSeen:true, bodies: ['HEADER.FIELDS (FROM TO SUBJECT DATE)']});\n            var f = imap.fetch(results, { struct: true, markSeen:true, bodies: '' });\n\n            f.on('message', function (msg, seqno) {\n                console.log('Message #%d', seqno);\n                var prefix = '(#' + seqno + ') ';\n\n                msg.on('body', function(stream, info) {\n                    var buffer = '';\n                    stream.on('data', function(chunk) {\n                        buffer += chunk.toString('utf8');\n                    });\n                    stream.once('end', function() {\n                        console.log(prefix + 'Parsed header: %s', Imap.parseHeader(buffer));\n                    });\n                });\n\n                msg.once('attributes', function(attrs) {\n                    var attachments = findAttachmentParts(attrs.struct);\n\n                    if (attachments === undefined)\n                        return;\n\n                    console.log(prefix + 'Has attachments: %d', attachments.length);\n                    for (var i = 0, len=attachments.length ; i < len; ++i) {\n                        var attachment = attachments[i];\n                        /*This is how each attachment looks like {\n                             partID: '2',\n                             type: 'application',\n                             subtype: 'octet-stream',\n                             params: { name: 'file-name.ext' },\n                             id: null,\n                             description: null,\n                             encoding: 'BASE64',\n                             size: 44952,\n                             md5: null,\n                             disposition: { type: 'ATTACHMENT', params: { filename: 'file-name.ext' } },\n                             language: null\n                             }\n                         */\n                        console.log(prefix + 'Fetching attachment %s', attachment.params.name);\n                        \n                        if (attachment.params.name === undefined)\n                            return;\n                            \n                        if (attachment.params.name.toUpperCase().indexOf(\".TGD\") < 0 &&\n                            attachment.params.name.toUpperCase().indexOf(\".DDD\") < 0 &&\n                            attachment.params.name.toUpperCase().indexOf(\".C1V\") < 0)\n                                return;\n                            \n                        var f = imap.fetch(attrs.uid , {bodies: [attachment.partID], struct: true });\n\n                        //build function to process attachment message\n                        f.on('message', buildAttMessageFunction(attachment));\n                    }\n                });\n                msg.once('end', function() {\n                    console.log(prefix + 'Finished email');\n                });\n            });\n\n            f.once('error', function(err) {\n                console.log('Fetch error: ' + err);\n            });\n\n            f.once('end', function() {\n                console.log('Done fetching all messages!');\n                imap.end();\n            });\n        });\n    });\n});\n\nimap.once('error', function(err) {\n    console.log(err);\n});\n\nimap.once('end', function() {\n    console.log('Connection ended');\n});\n\nimap.connect();\n\nreturn;","outputs":1,"noerr":0,"x":493,"y":290,"wires":[["67dfeb62.495974"]]},{"id":"b8fec780.8dea68","type":"http request","z":"2153ec83.169f54","name":"Get Organizations","method":"GET","ret":"obj","url":"http://localhost:3000/services/rest/Organizations?filter={\"where\": {\"mailboxEmail\": {\"neq\":  null }}}","x":318,"y":144,"wires":[["430093b1.e6494c"]]},{"id":"430093b1.e6494c","type":"splitter","z":"2153ec83.169f54","name":"Organizations Loop","property":"payload","x":272,"y":290,"wires":[["723995d8.9df14c"]]},{"id":"67dfeb62.495974","type":"debug","z":"2153ec83.169f54","name":"","active":true,"console":"false","complete":"false","x":734,"y":145,"wires":[]}]